#!/usr/bin/env python

import socket
import sys
import solver
import struct
import os
import subprocess
import time


def run_cmd(args, timeout=None, shell=False, autoerror=True):
    global last_child

    if timeout != None:
        fargs = ["/usr/bin/timeout", "-k", "1", str(timeout)] + args
    else:
        fargs = args
    pipe = subprocess.PIPE

    ntime = time.time()
    p = subprocess.Popen(fargs, stdout=pipe, stderr=pipe, shell=shell)
    last_child = p.pid
    stdout, stderr = p.communicate()
    etime = time.time() - ntime
    rc = p.returncode
    p.wait()
    last_child = None
    if autoerror and rc!=0:
        print("CMD:" + " ".join(fargs))
        print("STDOUT")
        print(stdout.decode('utf-8'))
        print("STDERR")
        print(stderr.decode('utf-8'))
        print("CMD: " + str(rc))

    return (stdout, stderr, rc, etime)


print("===== START")

for f in os.listdir("."):
    if f.endswith(".asm"):
        bname = f[:-4]+".bin"
        try:
            os.unlink(bname)
        except OSError:
            pass
        _, _, rc, _ = run_cmd(("nasm -o %s %s" % (bname, f)), shell=True)
        if rc!=0:
            print("NASM ERROR!")
            sys.exit(2)

tstr = b""
tstr += solver.get_math_string()
tstr += b"\n"
tstr += b"\n".join([str(n).encode("utf-8") for n in solver.generate_var_payload()])
tstr += b"\n"

with open("solution2", "wb") as fp:
    fp.write(tstr)

tstr = b""
tstr += solver.get_math_string("thirdpayload_firstbytes.bin")
tstr += b"\n"
tstr += b"\n".join([str(n).encode("utf-8") for n in solver.generate_var_payload()])
tstr += b"\n"

with open("solution1", "wb") as fp:
    fp.write(tstr)

print("===== END")

